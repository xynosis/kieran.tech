var SVGO, fs, iconPath, loadAliases, path, svgfont2js, svgo, svgpath;

fs = require("fs-extra");

svgfont2js = require("svgfont2js");

SVGO = require("svgo");

svgo = new SVGO({
  multipass: true
});

path = require("path");

svgpath = require("svgpath");

iconPath = require("./icon-path");

loadAliases = (less, re) => {
  var alias, m, match, unicode_hex;
  m = {};
  match = void 0;
  while (null !== (match = re.exec(less))) {
    alias = match[1];
    unicode_hex = match[2];
    if (m[unicode_hex] == null) {
      m[unicode_hex] = [];
    }
    m[unicode_hex].push(alias);
  }
  return m;
};

module.exports = (sets) => {
  return Promise.all(sets.map(async(set) => {
    var aliases, f, file, files, folder, glyph, glyphs, i, j, k, len, len1, len2, name, optimizers, processFile, re, ref, stat, tmpre;
    //console.log "processing icon set: " + set.name
    re = /d="([\w\s-.]*)"/;
    optimizers = [];
    if (set.svg) {
      if (set.re) {
        set.re = new RegExp(set.re, "g");
        aliases = loadAliases(fs.readFileSync(require.resolve(set.style), "utf8"), set.re);
      }
      glyphs = svgfont2js(fs.readFileSync(require.resolve(set.svg), "utf8"));
      for (i = 0, len = glyphs.length; i < len; i++) {
        glyph = glyphs[i];
        optimizers.push(new Promise((resolve) => {
          var d;
          d = new svgpath(glyph.path);
          if (set.translateY) {
            d = d.translate(0, set.translateY);
          }
          d = d.rel().toString();
          return svgo.optimize(`<svg width='${glyph.width}' height='${glyph.height}'><path d='${d}'/></svg>`, (result) => {
            var match;
            match = re.exec(result.data);
            if (match != null ? match[1] : void 0) {
              glyph.path = match[1];
              return resolve(glyph);
            } else {
              //console.log "#{set.name}: #{glyph.name} failed to match"
              return resolve(null);
            }
          });
        }));
      }
    } else if (set.folder) {
      ref = [`node_modules/${set.folder}`, `../${set.folder}`];
      for (j = 0, len1 = ref.length; j < len1; j++) {
        f = ref[j];
        folder = path.resolve(f);
        try {
          stat = (await fs.lstat(folder));
          if (stat.isDirectory()) {
            break;
          }
        } catch (error) {}
        folder = null;
      }
      if (folder) {
        processFile = (file, name) => {
          return fs.readFile(file, {
            encoding: "utf8"
          }).then((content) => {
            return new Promise((resolve, reject) => {
              var e;
              try {
                return svgo.optimize(content, (result) => {
                  var box, d;
                  d = re.exec(result.data);
                  box = /viewBox="0 0 ([0-9]+) ([0-9]+)"/.exec(result.data);
                  if ((d != null) && d.length > 1 && (box != null) && box.length > 2) {
                    return resolve({
                      name: name,
                      path: d[1],
                      width: box[1],
                      height: box[2]
                    });
                  } else {
                    //console.log "#{set.short}: #{name} failed to match"
                    return resolve(null);
                  }
                });
              } catch (error) {
                e = error;
                console.error(`svgo failed for file: ${file}`);
                console.error(e);
                return resolve();
              }
            });
          }).catch((e) => {
            console.error(`file: ${file}`);
            return console.error(e);
          });
        };
        files = (await fs.readdir(folder));
        tmpre = new RegExp(set.re, "i");
        for (k = 0, len2 = files.length; k < len2; k++) {
          file = files[k];
          if ((name = tmpre.exec(file)) != null) {
            optimizers.push(processFile(path.resolve(folder, file), name[1]));
          }
        }
      }
    }
    return Promise.all(optimizers).then(function(glyphs) {
      var alias, data, icon, l, len3, len4, n, names, tmp;
      data = {
        aliases: {},
        icons: {}
      };
      for (l = 0, len3 = glyphs.length; l < len3; l++) {
        glyph = glyphs[l];
        if (glyph != null) {
          if (set.svg && set.re) {
            tmp = glyph['unicode_hex'];
            if (tmp.length === 2) {
              tmp = "00" + tmp;
            } else if (tmp.length === 3) {
              tmp = "0" + tmp;
            }
            names = aliases[tmp];
          } else {
            names = [glyph.name];
          }
          if (names != null) {
            name = names.shift();
            icon = {
              d: glyph.path,
              w: glyph.width,
              h: glyph.height
            };
            if (names.length > 0) {
              for (n = 0, len4 = names.length; n < len4; n++) {
                alias = names[n];
                data.aliases[alias] = name;
              }
              icon.aliases = names;
            }
            data.icons[name] = icon;
          }
        }
      }
      console.log(`${set.short} (${set.name}): ${glyphs.length} glyphs, ${(Object.keys(data.icons).length)} icons, ${(Object.keys(data.aliases).length)} aliases`);
      return data;
    }).then(JSON.stringify).then(fs.writeFile.bind(null, path.resolve(iconPath, `${set.short}.json`)));
  }));
};
