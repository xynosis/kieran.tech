var _worker, chunkify, flatten, fork, path, shuffle;

({fork} = require("child_process"));

path = require("path");

flatten = (arrs) => {
  var arr, j, k, len1, len2, obj, ref, target;
  target = [];
  for (j = 0, len1 = arrs.length; j < len1; j++) {
    arr = arrs[j];
    if (Array.isArray(arr)) {
      ref = flatten(arr);
      for (k = 0, len2 = ref.length; k < len2; k++) {
        obj = ref[k];
        target.push(obj);
      }
    } else {
      target.push(arr);
    }
  }
  return target;
};

chunkify = (a, n) => {
  var i, len, out, size;
  if (n < 2) {
    return [a];
  }
  len = a.length;
  out = [];
  i = 0;
  if (len % n === 0) {
    size = Math.floor(len / n);
    while (i < len) {
      out.push(a.slice(i, i += size));
    }
  } else {
    while (i < len) {
      size = Math.ceil((len - i) / n--);
      out.push(a.slice(i, i += size));
    }
  }
  return out;
};

shuffle = (array) => {
  var counter, index, temp;
  counter = array.length;
  while (0 < counter) {
    index = Math.floor(Math.random() * counter);
    counter--;
    temp = array[counter];
    array[counter] = array[index];
    array[index] = temp;
  }
  return array;
};

if (path.extname(__filename) === ".coffee") {
  _worker = `${__dirname}/_worker.coffee`;
} else {
  _worker = `${__dirname}/_worker.js`;
}

module.exports = (work, options) => {
  return new Promise((resolve, reject) => {
    var chunks, current, i, j, onText, ref, remaining, results, worker, workers;
    if (!(options != null ? options.worker : void 0)) {
      reject(new Error("handle-that: no worker defined"));
    }
    if (options.flatten !== false) {
      work = flatten(work);
    }
    if ((remaining = work.length) > 0) {
      workers = Math.min(remaining, options.concurrency || require("os").cpus().length);
      if (options.shuffle !== false) {
        work = shuffle(work);
      }
      chunks = chunkify(work, Math.max(workers, remaining / Math.sqrt(2)));
      current = 0;
      if (options.onText != null) {
        if (options.silent == null) {
          options.silent = true;
        }
      }
      results = [];
      for (i = j = 0, ref = workers; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
        worker = fork(_worker, [path.resolve(options.worker), "--colors"], options);
        if ((onText = options.onText) != null) {
          ["stdout", "stderr"].forEach((std) => {
            std = worker[std];
            std.setEncoding("utf8");
            return std.on("data", (data) => {
              var lines;
              lines = data.split("\n");
              if (lines[lines.length - 1] === "") {
                lines.pop();
              }
              return onText(lines, remaining);
            });
          });
        }
        if (typeof options.onFork === "function") {
          options.onFork(worker);
        }
        results.push(worker.on("message", ((w, count) => {
          var pieces;
          pieces = chunks.shift();
          if (count) {
            remaining -= count;
            if (typeof options.onProgress === "function") {
              options.onProgress(remaining);
            }
          }
          if (pieces) {
            w.send({
              pieces: pieces,
              current: current,
              length: work.length
            });
            return current += pieces.length;
          } else {
            i--;
            w.disconnect();
            if (i === 0) {
              if (typeof options.onFinish === "function") {
                options.onFinish();
              }
              return resolve();
            }
          }
        }).bind(null, worker)));
      }
      return results;
    } else {
      if (typeof options.onFinish === "function") {
        options.onFinish();
      }
      return resolve();
    }
  });
};

module.exports.shuffle = shuffle;

module.exports.chunkify = chunkify;

module.exports.flatten = flatten;
