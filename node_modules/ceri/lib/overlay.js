var attach, clone, close, dEl, detach, getAnimateObj, getLastItem, isString, noop, overlay, ref, s, stack;

ref = require("./_helpers"), noop = ref.noop, isString = ref.isString, clone = ref.clone;

overlay = document.createElement("div");

s = overlay.style;

s.position = "fixed";

s.top = "-10px";

s.left = 0;

s.right = 0;

s.height = "120vh";

s.willChange = "opacity";

stack = [];

close = function(e) {
  var li;
  if (!e.defaultPrevented && (e.type === "click" || e.which === 27)) {
    if (((li = getLastItem()) != null) && !li.keepOpen) {
      li.close();
      return e.preventDefault();
    }
  }
};

overlay.addEventListener("click", close);

getLastItem = function(steps) {
  if (steps == null) {
    steps = 1;
  }
  return stack[stack.length - steps];
};

attach = function() {
  document.body.appendChild(overlay);
  return document.addEventListener("keyup", close);
};

detach = function() {
  document.body.removeChild(overlay);
  return document.removeEventListener("keyup", close);
};

dEl = document.documentElement;

getAnimateObj = function(o, li, getViewportSize) {
  var duration, ref1, source, target;
  if (li != null) {
    if ((ref1 = li.animation) != null) {
      if (typeof ref1.stop === "function") {
        ref1.stop();
      }
    }
  } else {
    li = {
      opacity: 0,
      done: detach,
      allowScroll: true
    };
    if (o.open) {
      attach();
    }
  }
  if (o.open) {
    duration = o.durationIn || 300;
    source = li;
    target = o;
  } else {
    duration = o.durationOut || 200;
    source = o;
    target = li;
  }
  s = dEl.style;
  if (target.allowScroll) {
    s.overflow = null;
    s.marginRight = null;
  } else {
    s.marginRight = getViewportSize().width - dEl.clientWidth + "px";
    s.overflow = "hidden";
  }
  target.animation = {
    animate: o.animate,
    el: overlay,
    style: {
      opacity: [source.opacity, target.opacity]
    },
    init: {
      backgroundColor: target.color || "black",
      zIndex: target.zIndex
    },
    duration: duration,
    done: target.done
  };
  return target.animation;
};

module.exports = {
  mixins: [require("./animate"), require("./getViewportSize"), require("./path"), require("./parseActive")],
  methods: {
    $overlay: function(o) {
      if (o == null) {
        o = clone(this.overlay) || {};
      }
      o.activate = function() {
        var k, li, ref1, ref2, v, val;
        ref1 = {
          zIndex: 995,
          opacity: 0.5,
          keepOpen: false,
          animate: true
        };
        for (k in ref1) {
          v = ref1[k];
          if ((val = o[k]) != null) {
            o[k] = this.$path.resolveValue(val);
          } else {
            o[k] = v;
          }
        }
        o.open = true;
        li = getLastItem();
        stack.push(o);
        o.close = (function(_this) {
          return function() {
            var i, ref2;
            o.close = noop;
            if (!o.open) {
              return;
            }
            o.open = false;
            if ((ref2 = _this.$path.resolveValue(o.onClose)) != null) {
              ref2.call(_this);
            }
            i = stack.indexOf(o);
            if (i === stack.length - 1) {
              return _this.$animate(getAnimateObj(stack.pop(), getLastItem(), _this.getViewportSize));
            } else {
              return stack.splice(i, 1);
            }
          };
        })(this);
        o.cancel = function() {
          var ref2;
          return (ref2 = o.animation) != null ? typeof ref2.toEnd === "function" ? ref2.toEnd() : void 0 : void 0;
        };
        if (li != null) {
          o.zIndex = Math.max(o.zIndex, li.zIndex + 5);
        }
        if ((ref2 = this.$path.resolveValue(o.onOpen)) != null) {
          ref2.call(this, o.zIndex);
        }
        this.$animate(getAnimateObj(o, li, this.getViewportSize));
        return o.close;
      };
      return this.$parseActive(o);
    }
  },
  connectedCallback: function() {
    if (this._isFirstConnect && this.overlay) {
      return this.$overlay(clone(this.overlay));
    }
  }
};
