var arrayize, camelize, extract, isElement, isFunction, isString, ref;

ref = require("./_helpers"), isElement = ref.isElement, isString = ref.isString, isFunction = ref.isFunction, arrayize = ref.arrayize, camelize = ref.camelize;

extract = function(options, extr) {
  var i, len, name, names, opts, ref1, t, type, val;
  if (!extr) {
    return [null, options];
  }
  opts = {};
  for (type in extr) {
    names = extr[type];
    t = type === "@" ? "on-" : type;
    for (i = 0, len = names.length; i < len; i++) {
      name = names[i];
      if ((val = (ref1 = options[name]) != null ? ref1[type] : void 0) != null) {
        delete options[name][type];
        if (Object.keys(options[name]).length === 0) {
          delete options[name];
        }
        opts[camelize(t + name)] = val;
      }
    }
  }
  return [options, opts];
};

module.exports = {
  _name: "structure",
  _v: 1,
  _prio: 800,
  _mergers: [
    require("./_merger").copy({
      source: "_elLookup"
    })
  ],
  _rebind: "$structure",
  mixins: [require("./directives")],
  methods: {
    "$structure": {
      beforeInsert: [],
      afterInsert: []
    },
    el: function(name, options, children) {
      var child, el, i, len, o, opts, ref1, ref2, type, types, value;
      if ((o = (ref1 = this._elLookup) != null ? ref1[camelize(name)] : void 0) != null) {
        if (o.cb == null) {
          o = {
            cb: o
          };
        }
        ref2 = extract(options, o.extract), options = ref2[0], opts = ref2[1];
        el = o.cb.call(this, opts, {
          children: children,
          name: name
        });
        if (el.el != null) {
          if (options == null) {
            options = el.options;
          }
          children = el.children;
          el = el.el;
        }
      } else {
        el = document.createElement(name);
      }
      if (options != null) {
        for (name in options) {
          types = options[name];
          for (type in types) {
            value = types[type];
            if (value.mods != null) {
              o = value.mods;
              o.value = value.val;
            } else {
              o = {
                value: value
              };
            }
            o.el = el;
            o.type = type;
            o.name = o.camel ? camelize(name) : name;
            this.$directive(o);
          }
        }
      }
      if ((children != null) && !isFunction(children)) {
        for (i = 0, len = children.length; i < len; i++) {
          child = children[i];
          if (isString(child)) {
            this._slots[child] = el;
          } else {
            el.appendChild(child);
          }
        }
      }
      return el;
    }
  },
  created: function() {
    return this._slots = {};
  },
  connectedCallback: function() {
    var child, el, fn, i, j, k, l, len, len1, len2, len3, ref1, ref2, ref3, ref4, ref5, slot, structure;
    if (this._isFirstConnect && (this.structure != null)) {
      structure = arrayize(this.structure());
      ref1 = this.$structure.beforeInsert;
      for (i = 0, len = ref1.length; i < len; i++) {
        fn = ref1[i];
        fn.call(this, structure);
      }
      ref2 = this.children;
      for (j = 0, len1 = ref2.length; j < len1; j++) {
        child = ref2[j];
        if (child != null) {
          slot = child.getAttribute("slot");
          if (slot != null) {
            if ((ref3 = this._slots[slot]) != null) {
              ref3.appendChild(slot);
            }
          } else {
            if ((ref4 = this._slots["default"]) != null) {
              ref4.appendChild(child);
            }
          }
        }
      }
      for (k = 0, len2 = structure.length; k < len2; k++) {
        el = structure[k];
        if (isString(el)) {
          this._slots[el] = this;
        } else {
          this.appendChild(el);
        }
      }
      ref5 = this.$structure.afterInsert;
      for (l = 0, len3 = ref5.length; l < len3; l++) {
        fn = ref5[l];
        fn.call(this);
      }
      return this.$structure = null;
    }
  }
};

;
