var concat;

concat = require("./_helpers").concat;

module.exports = {
  _rebind: "dataCache",
  mixins: [require("./props")],
  props: {
    chunksize: {
      type: Number,
      "default": 100
    }
  },
  methods: {
    getData: function() {
      return Promise.resolve([]);
    },
    dataCache: {
      _val: {},
      _count: null,
      _counter: null,
      _getter: {},
      update: function(index, data) {
        return this.dataCache._val[index] = data;
      },
      insert: function(count) {
        return this.dataCache.invalidate(this.dataCache._count + count);
      },
      invalidate: function(count) {
        var dc;
        dc = this.dataCache;
        dc._val = {};
        dc._count = count;
        dc._getter = {};
        return dc._counter = null;
      },
      get: function(start, end, options) {
        var chunks, chunksize, dc, gd, j, ref, ref1, results1;
        dc = this.dataCache;
        chunksize = this.chunksize;
        gd = this.getData;
        chunks = (function() {
          results1 = [];
          for (var j = ref = Math.floor(start / chunksize), ref1 = Math.floor((end - 1) / chunksize); ref <= ref1 ? j <= ref1 : j >= ref1; ref <= ref1 ? j++ : j--){ results1.push(j); }
          return results1;
        }).apply(this);
        return Promise.all(chunks.map(function(chunknr) {
          var cEnd, cStart, data, getter;
          if ((data = dc._val[chunknr]) != null) {
            return data;
          }
          if ((getter = dc._getter[chunknr]) != null) {
            return getter;
          }
          cStart = chunknr * chunksize;
          cEnd = cStart + chunksize;
          getter = dc._getter[chunknr] = gd(cStart, cEnd, options);
          getter.then(function(data) {
            if (dc._getter[chunknr] != null) {
              delete dc._getter[chunknr];
              return dc._val[chunknr] = data;
            }
          });
          return getter;
        })).then(function(results) {
          var cStart, chunkend, chunknr, chunkstart, data, i, k, len, result;
          result = [];
          for (i = k = 0, len = chunks.length; k < len; i = ++k) {
            chunknr = chunks[i];
            cStart = chunknr * chunksize;
            data = results[i];
            chunkstart = Math.max(start - cStart, 0);
            chunkend = Math.min(end - cStart, chunksize);
            concat(result, data.slice(chunkstart, chunkend));
          }
          return result;
        });
      },
      count: function(options) {
        var count, counter, dc;
        if (this.getCount != null) {
          dc = this.dataCache;
          if ((count = dc._count) != null) {
            return Promise.resolve(count);
          }
          if ((counter = dc._counter) != null) {
            return counter;
          }
          counter = dc._counter = this.getCount(options);
          counter.then(function(count) {
            if (dc._counter != null) {
              dc._counter = null;
              return dc._count = count;
            }
          });
          return counter;
        }
        return null;
      }
    }
  }
};
