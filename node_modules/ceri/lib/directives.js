var camelize, clone, isString, ref,
  slice = [].slice;

ref = require("./_helpers"), isString = ref.isString, clone = ref.clone, camelize = ref.camelize;

module.exports = {
  _name: "directives",
  _v: 1,
  _prio: 800,
  _mergers: [
    require("./_merger").concat({
      source: "directives"
    }), require("./_merger").copy({
      source: "_attrLookup"
    })
  ],
  mixins: [require("./setAttribute"), require("./parseElement"), require("./events"), require("./computed")],
  _attrLookup: {
    text: {
      ":": function(o) {
        return this.$computed.orWatch(o.value, function(val) {
          return o.el.innerText = val;
        });
      },
      "#": function(o) {
        return o.el.textContent = o.value;
      }
    },
    ref: {
      "#": function(o) {
        return this[o.value] = o.el;
      }
    }
  },
  methods: {
    $directive: function(o) {
      var cb, lookupObj;
      this.$parseElement.byObj(o);
      if(process.env.NODE_ENV!=='production' && !o.el){throw new Error(o.type + o.name + ' tried on not existing element')};
      if ((lookupObj = this._attrLookup[o.name]) != null) {
        if (lookupObj[o.type] != null) {
          return lookupObj[o.type].call(this, o);
        }
      }
      switch (o.type) {
        case "$":
          cb = (function(el, name, val) {
            return el[name] = val;
          }).bind(this, o.el, camelize(o.name));
          return this.$computed.orWatch(o.value, [cb]);
        case ":":
          cb = this.$setAttribute.bind(this, o.el, o.name);
          return this.$computed.orWatch(o.value, [cb]);
        case "@":
          if (o.cbs == null) {
            o.cbs = [o.value];
          }
          if (o.event == null) {
            o.event = o.name;
          }
          if (o.event && o.cbs.length > 0) {
            return this.$on(o);
          }
          break;
        case "~":
          if (this[o.name] == null) {
            this[o.name] = (function(_this) {
              return function() {
                var i, len, ref1, results;
                ref1 = _this[o.name]._cbs;
                results = [];
                for (i = 0, len = ref1.length; i < len; i++) {
                  cb = ref1[i];
                  results.push(cb.apply(null, arguments));
                }
                return results;
              };
            })(this);
          }
          if (o.event) {
            cb = (function(el, value, e) {
              return el.dispatchEvent(value, e);
            }).bind(null, o.el, o.value);
          } else {
            cb = (function() {
              var args, el, value;
              el = arguments[0], value = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];
              return el[value].apply(null, args);
            }).bind(null, o.el, o.value);
          }
          return this[o.name]._cbs.push(cb);
        default:
          return this.$setAttribute(o.el, o.name, o.value);
      }
    }
  },
  connectedCallback: function() {
    var directives, i, k, len, o, ref1, results, v;
    if (this._isFirstConnect) {
      ref1 = this.directives;
      results = [];
      for (i = 0, len = ref1.length; i < len; i++) {
        directives = ref1[i];
        results.push((function() {
          var results1;
          results1 = [];
          for (k in directives) {
            v = directives[k];
            o = clone(v);
            if (o.el == null) {
              o.el = k;
            }
            if (o.activate != null) {
              o.activated = false;
              results1.push(this.$computed.orWatch(o.activate, function(val) {
                if (val && !o.activated) {
                  this.$directive(o);
                  return o.activated = true;
                }
              }));
            } else {
              results1.push(this.$directive(o));
            }
          }
          return results1;
        }).call(this));
      }
      return results;
    }
  }
};

;
