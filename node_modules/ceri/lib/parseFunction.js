var concat, isFunction, isString, ref,
  slice = [].slice;

ref = require("./_helpers"), isString = ref.isString, isFunction = ref.isFunction, concat = ref.concat;

module.exports = {
  _name: "parseFunction",
  _v: 1,
  mixins: [require("./path"), require("./computed")],
  methods: {
    $parseFunction: function(value, cb) {
      var args2, fn, getArgumentsProcessor, hasArgs, path, splitted;
      if (isFunction(value)) {
        if (isFunction(cb)) {
          return cb.call(this, value);
        } else {
          return value;
        }
      }
      if (isString(value)) {
        splitted = value.replace(")", "").split("(");
        path = splitted.shift();
        if (hasArgs = splitted.length > 0) {
          args2 = splitted[0].split(",");
          getArgumentsProcessor = function(fn) {
            return function() {
              var args, tmp;
              args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
              tmp = args2.map((function(_this) {
                return function(path) {
                  var newPath;
                  newPath = path.replace(/[\"']/g, "");
                  if (newPath !== path) {
                    return newPath;
                  }
                  if (!isNaN(newPath)) {
                    return Number(newPath);
                  }
                  switch (newPath) {
                    case "true":
                      return true;
                    case "false":
                      return false;
                    default:
                      return _this.$path.resolveValue(path);
                  }
                };
              })(this));
              if (args != null) {
                concat(tmp, args);
              }
              return fn.apply(this, tmp);
            };
          };
        }
        if (isFunction(cb)) {
          return this.$computed.orWatch(path, function() {
            var args, fn, tmp;
            fn = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
            if (hasArgs && (fn != null) && isFunction(fn)) {
              fn = getArgumentsProcessor.call(this, fn);
            }
            tmp = [fn];
            if (args != null) {
              concat(tmp, args);
            }
            return cb.apply(this, tmp);
          });
        } else {
          fn = this.$path.resolveValue(path);
          if (isFunction(fn)) {
            if (hasArgs) {
              return getArgumentsProcessor.call(this, fn);
            }
            return fn;
          }
          return null;
        }
      }
    }
  }
};

;
