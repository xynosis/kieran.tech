var getID, isArray, isFunction, isObject, rebind, ref;

ref = require("./_helpers"), isObject = ref.isObject, isFunction = ref.isFunction, isArray = ref.isArray, rebind = ref.rebind, getID = ref.getID;

module.exports = function(ce) {
  var _merger, addReactionMerger, ceProto, flattenMixins, mergers;
  ceProto = ce.prototype;
  ceProto._isCeriProto = true;
  ceProto.$nextTick = require("./_nextTick");
  ceProto._inherit = function() {
    var o, p, ref1;
    o = Object.create(this);
    rebind(o);
    o.__parents = p = ((ref1 = this.__parents) != null ? ref1.slice() : void 0) || [];
    p.push(this);
    return o;
  };
  if (ceProto.mixins != null) {
    flattenMixins = function(mixins) {
      var addMixins, i, j, len, len1, mixin;
      addMixins = [];
      for (i = 0, len = mixins.length; i < len; i++) {
        mixin = mixins[i];
        if (mixin.mixins != null) {
          addMixins = flattenMixins(mixin.mixins).concat(addMixins);
        }
      }
      for (j = 0, len1 = addMixins.length; j < len1; j++) {
        mixin = addMixins[j];
        if (!~mixins.indexOf(mixin)) {
          mixins.push(mixin);
        }
      }
      return mixins;
    };
    flattenMixins(ceProto.mixins);
    _merger = require("./_merger");
    _merger.apply(ce, ceProto.mixins, _merger.concat({
      source: "_mergers",
      target: "mergers"
    }));
    mergers = ceProto.mergers;
    delete ceProto.mergers;
    mergers.push(_merger.copy({
      source: "methods",
      target: false
    }));
    mergers.push(_merger.concat({
      source: "_rebind"
    }));
    addReactionMerger = function(name, short) {
      var merger;
      merger = _merger.concat({
        source: name,
        target: short,
        last: true
      });
      merger.finisher = function(obj) {
        return obj.prototype[name] = function() {
          var fn, i, len, ref1, results;
          ref1 = this[short];
          results = [];
          for (i = 0, len = ref1.length; i < len; i++) {
            fn = ref1[i];
            results.push(fn.apply(this, arguments));
          }
          return results;
        };
      };
      return mergers.push(merger);
    };
    addReactionMerger("disconnectedCallback", "_dCb");
    addReactionMerger("attributeChangedCallback", "_acCb");
    addReactionMerger("adoptedCallback", "_aCb");
    mergers.push(_merger.concat({
      source: "connectedCallback",
      target: "_cCb",
      last: true,
      finisher: function(obj) {
        return obj.prototype.connectedCallback = function() {
          var fn, i, len, ref1;
          ref1 = this._cCb;
          for (i = 0, len = ref1.length; i < len; i++) {
            fn = ref1[i];
            fn.apply(this, arguments);
          }
          return this._isFirstConnect = false;
        };
      }
    }));
    addReactionMerger("destroy", "_deCb");
    mergers.push({
      source: "created",
      setup: function(obj) {
        obj._crCb = [
          function() {
            this._isCeri = true;
            this._isFirstConnect = true;
            this._ceriID = getID();
            return rebind(this);
          }
        ];
        return {
          iterate: function(entry) {
            return obj._crCb.push(entry);
          },
          end: function() {
            if (obj.created != null) {
              return obj._crCb.push(obj.created);
            }
          }
        };
      }
    });
    _merger.apply(ce, ceProto.mixins, mergers);
    if (typeof ceProto._registerTests === "function") {
      ceProto._registerTests(ce);
    }
  }
  return ce;
};

;
