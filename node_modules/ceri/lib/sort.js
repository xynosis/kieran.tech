var capitalize, clone, isArray, ref, sorting;

ref = require("./_helpers"), isArray = ref.isArray, clone = ref.clone, capitalize = ref.capitalize;

sorting = function(field, reverse, cast) {
  var getter;
  if (cast) {
    getter = function(obj) {
      return cast(obj[field]);
    };
  } else {
    getter = function(obj) {
      return obj[field];
    };
  }
  return function(a, b) {
    a = getter(a);
    b = getter(b);
    return reverse * ((a > b) - (b > a));
  };
};

module.exports = {
  _name: "sort",
  _v: 1,
  _mergers: [
    require("./_merger").concat({
      source: "sort"
    })
  ],
  _rebind: "$sort",
  mixins: [require("./computed")],
  methods: {
    $sort: {
      init: function(o) {
        var base, cSort;
        if ((base = this.$sort).__s == null) {
          base.__s = {};
        }
        this.$sort.__s[o.name] = o;
        o.watcher = this.$watch.path({
          parent: o,
          name: "sortBy",
          value: o.sortBy
        });
        cSort = this.$computed.init({
          get: function() {
            var fns;
            fns = o.sortBy.map(function(arg) {
              var cast, field, reverse;
              field = arg[0], reverse = arg[1], cast = arg[2];
              return sorting(field, reverse, cast);
            });
            if (fns.length === 0) {
              return null;
            }
            return function(a, b) {
              var fn, j, len, result;
              for (j = 0, len = fns.length; j < len; j++) {
                fn = fns[j];
                result = fn(a, b);
                if (result !== 0) {
                  return result;
                }
              }
              return 0;
            };
          }
        });
        this.$computed.init({
          path: "sort" + capitalize(o.name),
          get: function() {
            var dir, field, j, len, ref1, ref2, result;
            result = {};
            ref1 = o.sortBy;
            for (j = 0, len = ref1.length; j < len; j++) {
              ref2 = ref1[j], field = ref2[0], dir = ref2[1];
              result[field] = dir;
            }
            return result;
          }
        });
        this.$computed.init({
          path: "sort" + capitalize(o.name) + "Symbol",
          get: function() {
            var dir, field, j, len, ref1, ref2, result;
            result = {};
            ref1 = o.sortBy;
            for (j = 0, len = ref1.length; j < len; j++) {
              ref2 = ref1[j], field = ref2[0], dir = ref2[1];
              result[field] = dir > 0 ? '▲' : '▼';
            }
            return result;
          }
        });
        return this.$computed.init({
          path: "sorted" + capitalize(o.name),
          get: function() {
            var sorter, tmp;
            tmp = this.$path.resolveValue(o.name).slice();
            sorter = cSort.getter();
            if (sorter) {
              return tmp.sort(sorter);
            } else {
              return tmp;
            }
          }
        });
      },
      by: function(o) {
        var arr, direction, f, field, found, i, j, len, ref1, s, sortBy;
        if ((s = (ref1 = this.$sort.__s) != null ? ref1[o.target] : void 0) != null) {
          sortBy = s.sortBy;
          f = o.field;
          for (i = j = 0, len = sortBy.length; j < len; i = ++j) {
            arr = sortBy[i];
            field = arr[0], direction = arr[1];
            if (field === f) {
              arr[1] = -1 * direction;
              found = i;
            }
          }
          if (found == null) {
            if (o.add) {
              sortBy.push([f, 1]);
              return s.watcher.notify();
            } else {
              return s.sortBy = [[f, 1]];
            }
          } else if (!o.add) {
            return s.sortBy = sortBy.splice(found, 1);
          } else {
            return s.watcher.notify();
          }
        }
      }
    }
  },
  connectedCallback: function() {
    var j, k, len, ref1, results, sort, v;
    if (this._isFirstConnect) {
      ref1 = this.sort;
      results = [];
      for (j = 0, len = ref1.length; j < len; j++) {
        sort = ref1[j];
        results.push((function() {
          var results1;
          results1 = [];
          for (k in sort) {
            v = sort[k];
            if (!isArray(v[0])) {
              v = [v];
            }
            results1.push(this.$sort.init({
              name: k,
              sortBy: v
            }));
          }
          return results1;
        }).call(this));
      }
      return results;
    }
  }
};

;
