var capitalize, getCan, isArray, ref;

ref = require("./_helpers"), capitalize = ref.capitalize, isArray = ref.isArray;

getCan = function(name) {
  return "can" + capitalize(name);
};

module.exports = {
  _name: "states",
  _prio: 850,
  _v: 1,
  _mergers: [
    require("./_merger").copy({
      source: "states"
    })
  ],
  mixins: [require("./computed")],
  methods: {
    $states: function(name, states) {
      var can, k, o, v;
      this[name] = o = function(newState, value) {
        if (o._state) {
          if (value == null) {
            value = o[o._state];
          }
          o[o._state] = false;
        }
        if (value == null) {
          value = true;
        }
        o._state = newState;
        o[newState] = value;
        if (o._value !== value) {
          return o._value = value;
        }
      };
      this.$watch.path({
        parent: o,
        path: name + "._state"
      });
      this.$watch.path({
        parent: o,
        path: name + "._value"
      });
      for (k in states) {
        v = states[k];
        this.$watch.path({
          parent: o,
          name: k,
          value: false,
          path: name + "." + k,
          cbs: v.cbs,
          initial: v.initial || false
        });
        if (!(can = v.can)) {
          if (k !== "initial") {
            can = (function(k) {
              var tmp;
              return ~((tmp = states[o._state]).next || tmp).indexOf(k);
            }).bind(null, k);
          } else {
            can = function() {
              return true;
            };
          }
        }
        this.$computed.parseAndInit(can, {
          parent: o,
          name: getCan(k),
          parentPath: name
        });
      }
      return o("initial");
    }
  },
  connectedCallback: function() {
    var k, ref1, results, v;
    if (this._isFirstConnect) {
      ref1 = this.states;
      results = [];
      for (k in ref1) {
        v = ref1[k];
        results.push(this.$states(k, v));
      }
      return results;
    }
  }
};

;
