var clone, isArray, isFunction, isObject, isString, noop, ref;

ref = require("./_helpers"), isObject = ref.isObject, isFunction = ref.isFunction, isString = ref.isString, isArray = ref.isArray, noop = ref.noop, clone = ref.clone;

module.exports = {
  _name: "for",
  _v: 1,
  mixins: [require("./parseFunction")],
  methods: {
    $for: function(arg) {
      var _computed, _id, addComputed, anchor, c, computed, getEls, id, names, objs, process, template, templateWatcher, tmpl, valname, value;
      anchor = arg.anchor, template = arg.template, names = arg.names, value = arg.value, computed = arg.computed, id = arg.id;
      tmpl = null;
      ((_id = this.$path.resolveValue(id)) != null) || id;
      templateWatcher = this.$parseFunction(template, function(fn) {
        var el, k, l, len, len1, newEls, obj, oldEls, results;
        tmpl = fn;
        if (objs) {
          results = [];
          for (k = 0, len = objs.length; k < len; k++) {
            obj = objs[k];
            oldEls = obj._els;
            if ((fn != null) && isFunction(fn)) {
              newEls = obj._els = fn.call(obj);
              for (l = 0, len1 = newEls.length; l < len1; l++) {
                el = newEls[l];
                o.el.insertBefore(el, oldEls[0]);
              }
            } else {
              obj._els = [];
            }
            results.push((function() {
              var len2, m, results1;
              results1 = [];
              for (m = 0, len2 = oldEls.length; m < len2; m++) {
                el = oldEls[m];
                results1.push(el.remove());
              }
              return results1;
            })());
          }
          return results;
        }
      });
      getEls = function(obj) {
        if ((tmpl != null) && isFunction(tmpl)) {
          return tmpl.call(obj);
        } else {
          return [];
        }
      };
      objs = [];
      valname = names[0];
      if (computed != null) {
        _computed = this.$path.resolveValue(computed);
        addComputed = function(obj) {
          return obj.$computed.setup(_computed);
        };
      } else {
        addComputed = noop;
      }
      process = function(value) {
        var append, appendComments, getNext, i, indexname, j, k, key, keyname, keys, l, last, len, len1, len2, len3, m, n, obj, p, parent, q, ref1, remove, tmp, val;
        if (value != null) {
          last = null;
          parent = anchor.parentElement;
          getNext = function() {
            if (last != null) {
              return last._start;
            }
            return anchor;
          };
          appendComments = function(tmp) {
            var el, el2, next;
            el = tmp._start != null ? tmp._start : tmp._start = document.createComment("for-item-start");
            el2 = tmp._end != null ? tmp._end : tmp._end = document.createComment("for-item-end");
            next = getNext();
            parent.insertBefore(el, next);
            return parent.insertBefore(el2, next);
          };
          append = function(tmp) {
            var el, els, end, k, len, results;
            if (!tmp._appended) {
              tmp._appended = true;
              els = tmp._els;
              if (els != null) {
                end = tmp._end;
                results = [];
                for (k = 0, len = els.length; k < len; k++) {
                  el = els[k];
                  results.push(parent.insertBefore(el, end));
                }
                return results;
              }
            }
          };
          remove = function(tmp) {
            var el, els, end, results, tmpel;
            if (tmp._appended) {
              tmp._appended = false;
              els = tmp._els = [];
              el = tmp._start.nextSibling;
              end = tmp._end;
              results = [];
              while (el !== end) {
                tmpel = el;
                el = el.nextSibling;
                els.push(tmpel);
                results.push(tmpel.remove());
              }
              return results;
            }
          };
          if (isArray(value)) {
            if (names[1]) {
              indexname = names[1];
            }
            if (names[2]) {
              keyname = names[2];
            }
            for (i = k = value.length - 1; k >= 0; i = k += -1) {
              val = value[i];
              if (_id) {
                for (j = l = 0, len = objs.length; l < len; j = ++l) {
                  obj = objs[j];
                  if ((obj != null) && val[_id] === obj[valname][_id]) {
                    if (i !== j) {
                      objs[j] = objs[i];
                      tmp = objs[i] = obj;
                    }
                    break;
                  }
                }
              }
              if ((tmp != null) || ((tmp = objs[i]) != null)) {
                if (val !== tmp[valname]) {
                  tmp[valname] = val;
                }
                if (keyname && key !== tmp[keyname]) {
                  tmp[keyname] = "";
                }
                if (indexname && i !== tmp[indexname]) {
                  tmp[indexname] = i;
                }
              } else {
                tmp = objs[i] = this._inherit();
                tmp.$watch.path({
                  parent: tmp,
                  name: valname,
                  value: val,
                  path: valname
                });
                if (indexname) {
                  tmp.$watch.path({
                    parent: tmp,
                    name: indexname,
                    value: i,
                    path: indexname
                  });
                }
                if (keyname) {
                  tmp.$watch.path({
                    parent: tmp,
                    name: keyname,
                    value: "",
                    path: keyname
                  });
                }
                addComputed(tmp);
                tmp._els = getEls(tmp);
              }
              if (tmp._last !== i) {
                remove(tmp);
                appendComments(tmp);
              }
              append(tmp);
              tmp._last = i;
              last = tmp;
              tmp = null;
            }
            for (i = m = 0, len1 = objs.length; m < len1; i = ++m) {
              val = objs[i];
              if (value[i] == null) {
                remove(val);
              }
            }
          } else {
            if (names[2]) {
              indexname = names[2];
            }
            if (names[1]) {
              keyname = names[1];
            }
            keys = Object.keys(value);
            for (i = n = keys.length - 1; n >= 0; i = n += -1) {
              key = keys[i];
              val = value[key];
              if (_id) {
                for (j = p = 0, len2 = objs.length; p < len2; j = ++p) {
                  obj = objs[j];
                  if (i > j && (obj != null) && val[_id] === obj[valname][_id]) {
                    objs[j] = objs[i];
                    tmp = objs[i] = obj;
                    break;
                  }
                }
              }
              if ((tmp = objs[i]) != null) {
                if (val !== tmp[valname]) {
                  tmp[valname] = val;
                }
                if (keyname && key !== tmp[keyname]) {
                  tmp[keyname] = key;
                }
                if (indexname && i !== tmp[indexname]) {
                  tmp[indexname] = i;
                }
              } else {
                tmp = objs[i] = this._inherit();
                tmp.$watch.path({
                  parent: tmp,
                  name: valname,
                  value: val,
                  path: valname
                });
                if (indexname) {
                  tmp.$watch.path({
                    parent: tmp,
                    name: indexname,
                    value: i,
                    path: indexname
                  });
                }
                if (keyname) {
                  tmp.$watch.path({
                    parent: tmp,
                    name: keyname,
                    value: key,
                    path: keyname
                  });
                }
                addComputed(tmp);
                tmp._els = getEls(tmp);
              }
              if (tmp._last !== i) {
                remove(tmp);
                appendComments(tmp);
              }
              append(tmp);
              tmp._last = i;
              last = tmp;
              tmp = null;
            }
            ref1 = objs.slice(keys.length);
            for (q = 0, len3 = ref1.length; q < len3; q++) {
              val = ref1[q];
              remove(val);
            }
          }
          return value;
        }
      };
      if (value !== true) {
        c = this.$computed.orWatch(value, process);
      }
      return {
        scopes: objs,
        valueWatcher: c,
        process: process.bind(this),
        templateWatcher: templateWatcher
      };
    }
  }
};

;
