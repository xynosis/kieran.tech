var clone, clusterTmpl, clustersTmpl, isArray, isFunction, isObject, isString, noop, ref;

ref = require("./_helpers"), isObject = ref.isObject, isString = ref.isString, isFunction = ref.isFunction, isArray = ref.isArray, noop = ref.noop, clone = ref.clone;

clustersTmpl = function(){return [this.el("div",{"class":{":":"_clusterClasses.firstRow"},"ref":{"#":"firstRow"},"style":{":":function(){return 'height:'+this._frHeight+'px';}}},[]),this.el("div",{"class":{":":"_clusterClasses.lastRow"},"ref":{"#":"lastRow"},"style":{":":function(){return 'height:'+this._lrHeight+'px';}}},[])]}
;

clusterTmpl = function(){return [this.el("div",{"class":{":":"_clusterClasses.cluster"},"style":{":":function(){return 'overflow:hidden;position:relative;height:'+this._clusterHeight+'px';}},"ref":{"#":"_clusterel"}},[])]}
;

module.exports = {
  _name: "c-for-clustered",
  _v: 1,
  mixins: [require("./for"), require("./if"), require("./structure"), require("./detach"), require("./parseFunction"), require("./@resize")],
  methods: {
    $clusteredFor: function(o) {
      var anchor, c, clusterHeight, clusterSize, clusterVisible, clusters, clustersCount, container, el, getCount, getData, i, indexName, init, j, k, len, len1, loadingName, m, process, processScroll, ready, reattachContainer, ref1, ref2, ref3, rowCount, rowHeight, scopes, setData, settedUp, totalHeight, updateClusterCount, updateClusterHeight, updateRowCount, updateRowHeight;
      loadingName = o.loadingName || "isLoading";
      o.value = "_clusterData";
      o.main = m = this._inherit();
      m.$watch.path({
        parent: m,
        path: "_frHeight",
        value: 0
      });
      m.$watch.path({
        parent: m,
        path: "_lrHeight",
        value: 0
      });
      m._clusterClasses = o.classes;
      reattachContainer = this.$detach(container = o.container);
      settedUp = false;
      ready = false;
      init = (function(_this) {
        return function() {
          if (settedUp && ready) {
            init = null;
            _this.$on({
              event: "scroll",
              el: container,
              cbs: processScroll,
              throttled: true
            });
            _this.$on({
              event: "resize",
              el: container,
              delay: true,
              cbs: function() {
                updateClusterHeight();
                updateClusterCount();
                return processScroll(true);
              }
            });
            getData(0, 1).then(setData[0]).then(updateRowHeight).then(updateRowCount).then(processScroll);
            return reattachContainer();
          }
        };
      })(this);
      ref1 = clustersTmpl.call(m);
      for (j = 0, len = ref1.length; j < len; j++) {
        el = ref1[j];
        container.appendChild(el);
      }
      getData = null;
      getCount = null;
      this.$parseFunction(o.getData, function(fn) {
        getData = fn;
        if ((init != null) && isFunction(fn)) {
          ready = true;
          return init();
        }
      });
      this.$parseFunction(o.getCount, function(fn) {
        return getCount = fn;
      });
      o.clusters = clusters = [];
      setData = [];
      indexName = o.names[1];
      if (indexName) {
        o.names[1] = "_withinIndex";
        if (o.computed == null) {
          o.computed = {};
        }
        o.computed[indexName] = function() {
          return this._clusterIndex + this._withinIndex;
        };
      }
      ref2 = [0, 1, 2];
      for (k = 0, len1 = ref2.length; k < len1; k++) {
        i = ref2[k];
        clusters.push((c = m._inherit()));
        c.$watch.path({
          parent: c,
          path: loadingName,
          value: 0
        });
        c.$watch.path({
          parent: c,
          path: "_clusternr",
          value: i - 1
        });
        c.$watch.path({
          parent: c,
          path: "_clusterHeight",
          value: 0
        });
        if (indexName) {
          c.$computed.init({
            parent: c,
            path: "_clusterIndex",
            get: function() {
              return this._clusternr * clusterSize;
            }
          });
        }
        el = clusterTmpl.call(c)[0];
        anchor = document.createComment("for-anchor");
        container.insertBefore(el, m.lastRow);
        el.appendChild(anchor);
        el.style.position = "relative";
        o.anchor = anchor;
        ref3 = c.$for(o), process = ref3.process, scopes = ref3.scopes;
        setData.push(process);
        c._setData = process;
        c._forScopes = scopes;
      }
      rowHeight = 0;
      updateRowHeight = function() {
        var bottom, els, l, len2, rect, ref4, top;
        if (!(rowHeight = o.rowHeight)) {
          top = Number.MAX_VALUE;
          bottom = Number.MIN_VALUE;
          els = (ref4 = clusters[0]._forScopes[0]) != null ? ref4._els : void 0;
          if (els != null) {
            for (l = 0, len2 = els.length; l < len2; l++) {
              el = els[l];
              rect = el.getBoundingClientRect();
              top = Math.min(rect.top, top);
              bottom = Math.max(rect.bottom, bottom);
            }
            rowHeight = bottom - top;
          } else {
            rowHeight = 0;
          }
        }
        return updateClusterHeight();
      };
      clusterSize = 0;
      clusterHeight = 0;
      updateClusterHeight = function() {
        if (!(clusterSize = o.clusterSize)) {
          clusterSize = Math.ceil((container.offsetHeight || 1) / rowHeight);
          if (clusterSize % 2) {
            clusterSize++;
          }
        }
        return clusterHeight = clusterSize * rowHeight;
      };
      rowCount = 0;
      updateRowCount = function() {
        if (getCount != null) {
          return getCount().then(function(count) {
            rowCount = count;
            return updateClusterCount();
          });
        } else {
          rowCount = 0;
          return updateClusterCount();
        }
      };
      clustersCount = 0;
      totalHeight = 0;
      updateClusterCount = function() {
        if (rowCount) {
          clustersCount = Math.ceil(rowCount / clusterSize);
          return totalHeight = rowCount * rowHeight;
        }
      };
      clusterVisible = -1;
      processScroll = function(redraw) {
        var absNr, absNrs, end, l, len2, lr, start, top;
        if (clusterHeight && ((clusterVisible !== (clusterVisible = Math.floor(container.scrollTop / clusterHeight + 0.5))) || redraw === true)) {
          top = container.scrollTop;
          absNrs = [clusterVisible - 1, clusterVisible, clusterVisible + 1];
          lr = m.lastRow;
          for (l = 0, len2 = absNrs.length; l < len2; l++) {
            absNr = absNrs[l];
            c = clusters[(absNr + 3) % 3];
            if (c._clusternr !== (c._clusternr = absNr) || redraw === true) {
              if (absNr > -1 && ((getCount == null) || absNr < clustersCount)) {
                start = absNr * clusterSize;
                end = start + clusterSize;
                if (getCount != null) {
                  end = Math.min(end, rowCount);
                }
                c._clusterHeight = (end - start) * rowHeight;
                getData(start, end).then((function(c, loadingid, data) {
                  if (c[loadingName] === loadingid) {
                    c._setData(data);
                    return c[loadingName] = 0;
                  }
                }).bind(null, c, ++c[loadingName]));
              } else {
                c._setData([]);
                c._clusterHeight = 0;
                c[loadingName] = 0;
              }
            }
            container.insertBefore(c._clusterel, lr);
          }
          m._frHeight = Math.max(0, (clusterVisible - 1) * clusterHeight);
          if (getCount != null) {
            m._lrHeight = Math.max(0, totalHeight - (clusterVisible + 2) * clusterHeight);
          }
          return container.scrollTop = top;
        }
      };
      settedUp = true;
      if (typeof init === "function") {
        init();
      }
      return o;
    }
  }
};

;
