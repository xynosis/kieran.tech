var identity, noop, ref;

ref = require("./_helpers"), identity = ref.identity, noop = ref.noop;

module.exports = {
  _name: "combined",
  _v: 1,
  mixins: [require("./watch"), require("./computed")],
  methods: {
    $combined: function(o) {
      var combinedParent;
      this.$path.toNameAndParent(o);
      if (!o.parent.hasOwnProperty(o.name)) {
        Object.defineProperty(o.parent, o.name, {
          __proto__: null,
          value: {}
        });
      }
      combinedParent = o.parent[o.name];
      return Object.keys(o.value).forEach((function(_this) {
        return function(name) {
          var combined, computed, createObj, data, deferred, makeHiddenName, v;
          v = o.value[name];
          makeHiddenName = function(name2) {
            return "__" + name + "_" + name2;
          };
          createObj = function(obj) {
            obj.path = o.path + "." + obj.name;
            obj.parent = combinedParent;
            return obj;
          };
          if (v.computed != null) {
            computed = makeHiddenName("computed");
            _this.$computed.init(createObj({
              name: computed,
              get: v.computed
            }));
          } else {
            computed = null;
          }
          if (v.data != null) {
            data = name;
            _this.$watch.path(createObj({
              name: data,
              value: v.data.call(_this)
            }));
          } else {
            data = null;
          }
          combined = makeHiddenName("combined");
          deferred = function() {
            var getterFactory;
            getterFactory = function(parent, combined, prop, computed, data, normalize, parseProp) {
              var getter;
              getter = function() {
                var k, obj, propVal, ref1, ref2;
                if (prop && ((propVal = this[prop]) != null)) {
                  obj = normalize(parseProp(propVal));
                } else {
                  obj = {};
                }
                if (computed) {
                  ref1 = normalize(parent[computed]);
                  for (k in ref1) {
                    v = ref1[k];
                    if (obj[k] == null) {
                      obj[k] = v;
                    }
                  }
                }
                if (data) {
                  ref2 = normalize(parent[data]);
                  for (k in ref2) {
                    v = ref2[k];
                    if (obj[k] == null) {
                      obj[k] = v;
                    }
                  }
                }
                return obj;
              };
              return getter.bind(this);
            };
            return this.$computed.init(createObj({
              name: combined,
              cbs: o.cbFactory.call(this, name),
              get: getterFactory.call(this, combinedParent, combined, v.prop, computed, data, o.normalize || identity, o.parseProp || identity)
            }));
          };
          if (_this.$computed.__deferredInits) {
            Object.defineProperty(combinedParent, combined, {
              configurable: true,
              set: noop,
              get: noop
            });
            return _this.$computed.__deferredInits.push(deferred);
          } else {
            return deferred.call(_this);
          }
        };
      })(this));
    }
  }
};

;
