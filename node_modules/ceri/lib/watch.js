var arrayize, assign, clone, concat, getID, instancesStr, isArray, isObject, isPlainObject, isString, merger, ref, watchStr,
  hasProp = {}.hasOwnProperty;

ref = require("./_helpers"), arrayize = ref.arrayize, isString = ref.isString, isArray = ref.isArray, isObject = ref.isObject, isPlainObject = ref.isPlainObject, clone = ref.clone, getID = ref.getID, concat = ref.concat, assign = ref.assign;

merger = require("./_merger");

watchStr = "__watch__";

instancesStr = "__instances__";

module.exports = {
  _name: "watch",
  _prio: 1000,
  _v: 1,
  _mergers: [
    merger.copy({
      source: "watch",
      target: "_watch"
    }), merger.concat({
      source: "data"
    })
  ],
  _rebind: "$watch",
  mixins: [require("./path"), require("./parseFunction")],
  methods: {
    $watch: {
      __w: {},
      getObj: function(o) {
        var i, obj, p;
        if (o.path != null) {
          if (!(obj = this.$watch.__w[o.path]) && ((p = this.__parents) != null)) {
            i = p.length;
            while (!obj && i) {
              obj = p[--i].$watch.__w[o.path];
            }
          }
          return obj;
        }
        return null;
      },
      setObj: function(o) {
        var w;
        o = (w = this.$watch).sharedInit(o);
        if (o.path != null) {
          w.__w[o.path] = o;
        }
        return o;
      },
      notify: function(path) {
        var o, ref1;
        if (!(o = this.$watch.getObj({
          path: path
        }))) {
          if (!(o = (ref1 = this.__parent) != null ? ref1.$watch.getObj({
            path: path
          }) : void 0)) {
            if(process.env.NODE_ENV!=='production' && true){console.warn('watch: couldn\'t notify ' + path)};
            return;
          }
        }
        return o.notify(o.value);
      },
      parseCbs: function(o, prop) {
        return o[prop] = arrayize(o[prop]).map(this.$parseFunction.bind(this));
      },
      parse: function(obj, shouldClone) {
        if (!isObject(obj)) {
          obj = {
            cbs: obj
          };
        } else if (shouldClone) {
          obj = clone(obj);
        }
        if (!obj.__parsed__) {
          this.$watch.parseCbs(obj, "cbs");
          if (obj.initial !== false) {
            if (!obj.initial) {
              obj.initial = obj.cbs.slice();
            } else {
              this.$watch.parseCbs(obj, "initial");
            }
          }
          obj.__parsed__ = true;
        }
        return obj;
      },
      merge: function(o1, o2) {
        concat(o1.cbs, o2.cbs);
        if (o2.initial) {
          if (o1.initial) {
            concat(o1.initial, o2.initial);
          } else {
            o1.initial = o2.initial;
          }
        }
        if (o2.parent != null) {
          o1.parent = o2.parent;
          if (o1.__init__) {
            this.$watch.setupParent(o1);
          }
        }
        if (o2.hasOwnProperty("value") && o2.value !== o1.value) {
          return o1.parent[o1.name] = o2.value;
        }
      },
      getConfig: function(o) {
        var c, ref1, tmp, w;
        if (!o.__configured__ && (o.path != null) && ((tmp = (ref1 = this._watch) != null ? ref1[o.path] : void 0) != null)) {
          w = this.$watch;
          c = w.parse(tmp, true);
          w.merge(o, c);
          return o.__configured__ = true;
        }
      },
      init: function(o) {
        var obj, w;
        w = this.$watch;
        obj = w.getObj(o);
        if (obj != null ? obj.__init__ : void 0) {
          w.merge(obj, o);
          return obj;
        } else {
          w.getConfig(o);
          if (obj) {
            w.merge(obj, o);
            return w.sharedInit(obj);
          } else {
            return w.setObj(o);
          }
        }
      },
      sharedInit: function(o) {
        if (!o.__sInit__) {
          o.__sInit__ = true;
          o.cDeps = [];
          o._taints = null;
          o.id = getID();
          o.instance = this;
          o.checkComputed = function() {
            var cai, cd, ins;
            if (((cd = window.__ceriDeps) != null) && (cd[o.id] == null) && ((cai = window.__ceriActiveInstance) === null || ((ins = o.instance) === cai || ((cai.__parents != null) && ~cai.__parents.indexOf(ins))))) {
              o.cDeps.push(cd(o));
              return o.nullTaints();
            }
          };
        }
        return o;
      },
      setupParent: function(o) {
        var desc, i, name, obj, oldArr, parent, wrapper;
        parent = o.parent;
        name = o.name;
        if (o.oldParent !== parent) {
          if ((oldArr = o.watchArr) != null) {
            if (~(i = oldArr.indexOf(o))) {
              oldArr.splice(i, 1);
            }
            delete o.watchArr;
          }
          o.oldParent = parent;
          if (((desc = Object.getOwnPropertyDescriptor(parent, name)) == null) || !desc.get) {
            Object.defineProperty(parent, name, {
              configurable: true,
              enumerable: true,
              get: function() {
                var j, len, obj, ref1;
                ref1 = wrapper.objs;
                for (j = 0, len = ref1.length; j < len; j++) {
                  obj = ref1[j];
                  obj.checkComputed();
                }
                return wrapper.value;
              },
              set: function(newVal) {
                var j, len, obj, ref1, results;
                wrapper.value = newVal;
                ref1 = wrapper.objs;
                results = [];
                for (j = 0, len = ref1.length; j < len; j++) {
                  obj = ref1[j];
                  obj.oldVal = obj.value;
                  obj.value = newVal;
                  obj.instance.$watch.processNewValue(obj);
                  results.push(obj.notify(newVal, obj.oldVal));
                }
                return results;
              }
            });
          }
        }
        if (!o.watchArr) {
          if (!parent._isCeri) {
            if ((wrapper = parent[watchStr]) == null) {
              wrapper = {};
              obj = {};
              obj[watchStr] = {
                value: wrapper
              };
              parent.__proto__ = Object.create(parent.__proto__, obj);
            }
            wrapper = wrapper[name] != null ? wrapper[name] : wrapper[name] = {
              objs: [],
              value: o.value
            };
            wrapper.objs.push(o);
          } else {
            wrapper = {
              objs: [o],
              value: o.value
            };
          }
          o.watchArr = wrapper.objs;
        }
        return o;
      },
      path: function(o) {
        var cb, j, len, obj, ref1;
        if ((o.parentPath != null) && (o.name != null)) {
          o.path = o.parentPath + "." + o.name;
        }
        this.$path.toNameAndParent(o);
        this.$watch.parse(o);
        if (!o.parent) {
          if ((obj = this.$watch.getObj(o)) != null) {
            this.$watch.merge(obj, o);
            if(process.env.NODE_ENV!=='production' && o.value != null){console.warn('can\'t set ' + o.value + ' on ' + o.path + ' yet. Parent isn\'t setted yet')};
            return;
          } else {
            this.$watch.setObj(o);
          }
        } else {
          o = this.$watch.init(o);
          if (!o.__init__) {
            o.__init__ = true;
            if (o.value == null) {
              o.value = o.parent[o.name];
            }
            o.nullTaints = function() {
              return o._taints = null;
            };
            o.notify = function(val, oldVal) {
              var cb, j, l, len, len1, ref1, ref2, taints;
              if ((taints = o._taints) == null) {
                taints = o._taints = o.cDeps.reduce((function(h, c) {
                  return c.getTaints(h, true);
                }), {
                  _taints: []
                })._taints;
              }
              ref1 = taints.map((function(_this) {
                return function(taint) {
                  return taint();
                };
              })(this));
              for (j = 0, len = ref1.length; j < len; j++) {
                cb = ref1[j];
                cb();
              }
              ref2 = o.cbs;
              for (l = 0, len1 = ref2.length; l < len1; l++) {
                cb = ref2[l];
                cb.call(o.instance, val, oldVal, o);
              }
            };
            this.$watch.setupParent(o);
            this.$watch.processNewValue(o);
          }
          if (o.initial) {
            if (o.value != null) {
              ref1 = o.initial;
              for (j = 0, len = ref1.length; j < len; j++) {
                cb = ref1[j];
                cb.call(this, o.value);
              }
            } else if (o.dirty) {
              o.notify(o.value);
            }
            o.initial = false;
          }
        }
        return o;
      },
      processNewValue: function(o) {
        var child, isValidObj, k, obj, parent, ref1, results, v;
        child = o.value;
        parent = o.parent;
        isValidObj = function(obj) {
          return (obj != null) && isObject(obj) && !isArray(obj) && !(obj != null ? obj._isCeri : void 0);
        };
        if (isValidObj(child)) {
          for (k in child) {
            if (!hasProp.call(child, k)) continue;
            v = child[k];
            this.$watch.path({
              parent: child,
              name: k,
              value: v,
              parentPath: o.path
            });
          }
          if (o.oldVal && isValidObj(o.oldVal)) {
            ref1 = o.oldVal;
            results = [];
            for (k in ref1) {
              if (!hasProp.call(ref1, k)) continue;
              v = ref1[k];
              if (!child.hasOwnProperty(k)) {
                if ((obj = this.$watch.getObj({
                  path: o.path + "." + k
                })) != null) {
                  results.push(obj.notify(null, v));
                } else {
                  results.push(void 0);
                }
              } else {
                results.push(void 0);
              }
            }
            return results;
          }
        }
      }
    }
  },
  created: function() {
    var fn, j, k, len, obj, ref1, results, v, v2;
    ref1 = this.data;
    results = [];
    for (j = 0, len = ref1.length; j < len; j++) {
      fn = ref1[j];
      obj = fn.call(this);
      results.push((function() {
        var results1;
        results1 = [];
        for (k in obj) {
          v = obj[k];
          if (((v2 = this[k]) != null) && isPlainObject(v) && isPlainObject(v2)) {
            v = assign(v2, v);
          }
          results1.push(this.$watch.path({
            parent: this,
            name: k,
            value: v,
            path: k
          }));
        }
        return results1;
      }).call(this));
    }
    return results;
  }
};

;
